


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AddPurchase</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">UseCases</a>
</div>

<h1>Coverage Summary for Class: AddPurchase (UseCases)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AddPurchase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.5%
  </span>
  <span class="absValue">
    (62/78)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package UseCases;
&nbsp;
&nbsp;import DataAccessInterface.GroupDataInterface;
&nbsp;import DataAccessInterface.ItemDataInterface;
&nbsp;import DataAccessInterface.UserDataInterface;
&nbsp;import DataStructures.PurchaseInfo;
&nbsp;import DataStructures.UpdatedLists;
&nbsp;import Entities.*;
&nbsp;import InputBoundary.AddPurchaseBoundaryIn;
&nbsp;import OutputBoundary.AddPurchaseBoundaryOut;
&nbsp;import com.fasterxml.jackson.core.JsonProcessingException;
&nbsp;import org.json.simple.parser.ParseException;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;
<b class="fc">&nbsp;public class AddPurchase implements AddPurchaseBoundaryIn {</b>
&nbsp;    private PurchaseInfo purchaseInfo;
&nbsp;    private Item purchasedItem;
&nbsp;    private List&lt;User&gt; participatingUsers;
&nbsp;    private float price;
&nbsp;    private Group purchaseGroup;
&nbsp;    private User buyer;
&nbsp;    private AddPurchaseBoundaryOut presenter;
&nbsp;    private GroupDataInterface groupData;
&nbsp;    private ItemDataInterface itemData;
&nbsp;    private UserDataInterface userData;
&nbsp;    private UpdatedLists newLists;
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the item being purchased from the planning list and assigns the buyer, price, and users involved
&nbsp;     * in the purchase
&nbsp;     * to the item entity object then adds it to the purchased list of the group, saves the new group information
&nbsp;     * to the database,
&nbsp;     * then returns the new lists to be displayed to the view
&nbsp;     * @param purchaseInfo the data structure containing all the information required to make a purchase and
&nbsp;     *                     update the necessary data
&nbsp;     * @return the information that is prepared by the presenter to the controller
&nbsp;     */
&nbsp;    @Override
&nbsp;    public UpdatedLists executeUseCase(PurchaseInfo purchaseInfo) {
<b class="fc">&nbsp;        this.purchaseInfo = purchaseInfo;</b>
&nbsp;        // Calling the helper method which instantiates values for the attribute variables which is extracted
&nbsp;        // from the purchaseInfo data structure
<b class="fc">&nbsp;        extractInformation(purchaseInfo);</b>
&nbsp;
<b class="fc">&nbsp;        System.out.println(this.purchasedItem);</b>
&nbsp;
&nbsp;        // Obtain the planning list from the group and then remove the item that&#39;s being purchased from it to
&nbsp;        // move it to the purchased list
<b class="fc">&nbsp;        PlanningList planningList = this.purchaseGroup.getPlanningList();</b>
<b class="fc">&nbsp;        boolean removeCheck = planningList.removeFromList(this.purchasedItem);</b>
<b class="fc">&nbsp;        System.out.println(planningList);</b>
<b class="fc">&nbsp;        System.out.println(removeCheck);</b>
<b class="fc">&nbsp;        if (!removeCheck) {</b>
<b class="nc">&nbsp;            raiseError(&quot;Item could not be removed from planning list, either the information &quot; +</b>
&nbsp;                    &quot;was incorrect or the item did not exist in the list&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // Obtain the purchase list from the group and then update it using the addToPurchase helper function,
&nbsp;        // which adds the new item to the groups purchase list
<b class="fc">&nbsp;        PurchaseList purchaseList = this.purchaseGroup.getPurchaseList();</b>
<b class="fc">&nbsp;        addToPurchase(purchaseList);</b>
&nbsp;
&nbsp;        // Instantiate new 2 dimensional lists to store the information on the new purchase and planning list
&nbsp;        // which will be returned to update the view through the output boundary and presenter
&nbsp;        // These functions call the convertList helper method as they share a lot of functionality
<b class="fc">&nbsp;        List&lt;List&lt;String&gt;&gt; planningListItemIds = convertList(planningList);</b>
<b class="fc">&nbsp;        List&lt;List&lt;String&gt;&gt; purchasedListItemIds = convertList(purchaseList);</b>
<b class="fc">&nbsp;        newLists = new UpdatedLists(planningListItemIds, purchasedListItemIds);</b>
&nbsp;
&nbsp;        // Call a helper function to write the updated data in to the database using the interfaces
<b class="fc">&nbsp;        writeData();</b>
&nbsp;
<b class="fc">&nbsp;        raiseError(&quot;Success&quot;);</b>
&nbsp;
&nbsp;        // Call the presenter through the output boundary with the updated lists data structure
<b class="fc">&nbsp;        return this.presentInformation();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Call the presenter to return information to the view
&nbsp;     * @return the correct view based on if the use case failed or succeeded
&nbsp;     */
&nbsp;    private UpdatedLists presentInformation() {
<b class="fc">&nbsp;        if (Objects.equals(this.newLists.getResultMessage(), &quot;Success&quot;)) {</b>
<b class="fc">&nbsp;            return this.presenter.prepareSuccessViewInformation(this.newLists);</b>
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;            return this.presenter.prepareFailViewInformation(this.newLists);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Write the new group and item data to the database
&nbsp;     */
&nbsp;    private void writeData() {
&nbsp;        // Need to use a try catch in case of a IO exception
&nbsp;        try {
&nbsp;            // since the group and item data is updated, the boundaries are used to update the json files storing
&nbsp;            // this information
<b class="fc">&nbsp;            this.groupData.addorUpdateGroup(this.purchaseInfo.getPurchaseGroup(), this.purchaseGroup.toString());</b>
<b class="fc">&nbsp;            this.itemData.addorUpdateItem(this.purchaseInfo.getItemId(), this.purchasedItem.toString());</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
&nbsp;            // in the case of the io exception, we return a runtime exception
<b class="nc">&nbsp;            raiseError(&quot;IO Exception&quot;);</b>
<b class="nc">&nbsp;        } catch (ParseException e) {</b>
<b class="nc">&nbsp;            raiseError(&quot;Parse Exception&quot;);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Update the information of the item with the purchase and add it to the purchase list of the group
&nbsp;     * @param purchaseList the object of the purchase list of the group to add the item to
&nbsp;     */
&nbsp;    private void addToPurchase(PurchaseList purchaseList) {
&nbsp;        // Set the new attributes for the item which only have values when the purchase is made,
&nbsp;        // price, buyer, involved users
<b class="fc">&nbsp;        this.purchasedItem.setPrice(this.price);</b>
<b class="fc">&nbsp;        this.purchasedItem.setBuyer(this.buyer.getUsername());</b>
<b class="fc">&nbsp;        List&lt;String&gt; participatingUsernames = extractUsernames(this.participatingUsers);</b>
<b class="fc">&nbsp;        this.purchasedItem.setUsersInvolved(participatingUsernames);</b>
&nbsp;        // update the purchased list of the group with the new item with updated information
<b class="fc">&nbsp;        purchaseList.addItems(this.purchasedItem);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a list of users into a list of strings of their usernames
&nbsp;     * @param users the list of users
&nbsp;     * @return the list of usernames of the users in the list participatingUsers
&nbsp;     */
&nbsp;    private List&lt;String&gt; extractUsernames(List&lt;User&gt; users) {
<b class="fc">&nbsp;        List&lt;String&gt; tempList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        for (User user : users) {</b>
<b class="fc">&nbsp;            tempList.add(user.getUsername());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return tempList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extract the information from the purchase info data structure into the appropriate variables
&nbsp;     * @param purchaseInfo the data structure package containing the required information
&nbsp;     */
&nbsp;    private void extractInformation(PurchaseInfo purchaseInfo) {
&nbsp;        //grab and instantiate the data access boundaries because they are needed for the rest of the extraction process
<b class="fc">&nbsp;        this.groupData = purchaseInfo.getGroupData();</b>
<b class="fc">&nbsp;        this.itemData = purchaseInfo.getItemData();</b>
<b class="fc">&nbsp;        this.userData = purchaseInfo.getUserData();</b>
&nbsp;
<b class="fc">&nbsp;        this.participatingUsers = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;        // remember need try catches for all the IO or json exceptions
&nbsp;        //use data boundaries to parse the information and grab the class attribute variables as objects of the entities
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            this.purchasedItem = Item.fromString(this.itemData.itemAsString(this.purchaseInfo.getItemId()));</b>
<b class="nc">&nbsp;        } catch (IOException | ParseException e) {</b>
<b class="nc">&nbsp;            raiseError(&quot;JSON Processing Exception&quot;);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // need another helper function to extract the users lol, helper for a helper
<b class="fc">&nbsp;        extractUsers(purchaseInfo);</b>
<b class="fc">&nbsp;        this.price = purchaseInfo.getPrice();</b>
&nbsp;        try {
<b class="fc">&nbsp;            this.purchaseGroup = Group.fromString(this.groupData.groupAsString(purchaseInfo.getPurchaseGroup()));</b>
<b class="nc">&nbsp;        } catch (IOException | ParseException e) {</b>
<b class="nc">&nbsp;            raiseError(&quot;JSON Processing Exception&quot;);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;        try {
<b class="fc">&nbsp;            this.buyer = User.fromString(this.userData.userAsString(purchaseInfo.getBuyer()));</b>
<b class="nc">&nbsp;        } catch (IOException | ParseException e) {</b>
<b class="nc">&nbsp;            raiseError(&quot;JSON Processing Exception&quot;);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // grab the presenter from the input data structure
<b class="fc">&nbsp;        this.presenter = purchaseInfo.getPresenter();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an error message to the presenter to inform the user through the view that the use case failed
&nbsp;     * @param errorMessage the message to pass back to the user through the view
&nbsp;     */
&nbsp;    private void raiseError(String errorMessage) {
<b class="fc">&nbsp;        if (!Objects.equals(errorMessage, &quot;Success&quot;)) {</b>
<b class="nc">&nbsp;            this.newLists = new UpdatedLists(errorMessage);</b>
<b class="nc">&nbsp;            this.presenter.prepareFailViewInformation(newLists);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function for extractInformation to grab the users from the database using the usernames
&nbsp;     * @param purchaseInfo the data structure package containing the required information
&nbsp;     */
&nbsp;    private void extractUsers(PurchaseInfo purchaseInfo) {
&nbsp;        // this function needs to iterate through the usernames passed in from the controller and boundary
&nbsp;        // then use the data access boundary and User static functions to get a list of user entity objects from that
<b class="fc">&nbsp;        List&lt;String&gt; usernames = purchaseInfo.getUsers();</b>
<b class="fc">&nbsp;        for (String username : usernames) {</b>
&nbsp;            // need a try catch for the json processing exception
&nbsp;            try {
<b class="fc">&nbsp;                this.participatingUsers.add(User.fromString(this.userData.userAsString(username)));</b>
<b class="nc">&nbsp;            } catch (IOException | ParseException e) {</b>
<b class="nc">&nbsp;                raiseError(e.toString());</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            // yay O(n) time
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Abstract method used to convert the planning and purchased lists from the group into the format
&nbsp;     * of the lists that are returned to the view through the updatedLists data structure
&nbsp;     * @param inputList the list to be converted into the format for returning
&nbsp;     * @return the inputList in the format that needs to be returned, which is a 2 dimensional list
&nbsp;     */
&nbsp;    public List&lt;List&lt;String&gt;&gt; convertList(ItemList inputList) {
&nbsp;        // this class is abstracted to convert the new planning and purchase lists from the group
&nbsp;        // into the format of 2 dimensional lists with the required data to show the modification on the view
<b class="fc">&nbsp;        List&lt;List&lt;String&gt;&gt; tempListItemStrings = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        for (Item item : inputList) {</b>
<b class="fc">&nbsp;            List&lt;String&gt; tempList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            tempList.add(item.getItemId());</b>
<b class="fc">&nbsp;            tempList.add(item.getItemName());</b>
&nbsp;            // since only purchased items have a price and buyer, need to check the
&nbsp;            // instance of which list is being updated
<b class="fc">&nbsp;            if (inputList instanceof PurchaseList) {</b>
<b class="fc">&nbsp;                tempList.add(String.valueOf(item.getPrice()));</b>
<b class="fc">&nbsp;                tempList.add(item.getBuyer());</b>
&nbsp;            }
&nbsp;            // add the list to the outer list, yay O(n) time
<b class="fc">&nbsp;            tempListItemStrings.add(tempList);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return tempListItemStrings;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-12-05 00:39</div>
</div>
</body>
</html>
